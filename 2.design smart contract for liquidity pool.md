In this section, let's see how we can design the smart contract for liquiditty pool. The smart contract will responsible for creating a pair of tokens, and make sure the product of token number of the pair remain as a constant. First we will 
design an interface for the liquidity poll smart contract, since the logic of the code is a little bit complex, we will grow the code of the contract step by step, first we give a set of functions in the interface which is need to be 
implemented by each liquidity pool contract, create a file name ITokenPair.sol in backend/contract/interface, and add the following code:

```sol
//SPDX-License-Identifier: MIT

interface ITokenPair {
    /*
    this method return the address of smart contract
    that implement the interface
    */
    function factory() external view returns (address);

    /*
    This method return the address of stmart contract
    used to manage tokenA in the pair
    */
    function tokenA() external view returns (address);

    /*
    This method return the address of stmart contract
    used to manage tokenA in the pair
    */
    function tokenB() external view returns (address);

    /*
    This method return the constant product of number of 
    tokenA and tokenB
    */
    function KLast() external view returns(uint256);
}
```

Then we create a file named TokenPair.sol in the contract directory, it will implement methods of above interface, the code is as following:

```sol
//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./interfaces/ITokenPair.sol";

contract TokenPair is ITokenPair, ERC20 {
    address public factory;
    address public tokenA;
    address public tokenB;
    uint256 public KLast;
}
```
The above code indicates the TokenPair smart contract need to implement interfaces from ITokenPair and ERC20, as we have seen before, ERC20 is used for token generation and management. Let's see how we can implement interface of ITokenPari
for the smart contract above:

```sol
contract TokenPair is ITokenPair, ERC20 {
    ....
    constructor() ERC20("DEX Token Pair", "DEX-TP") {
        factory = msg.sender;
    }

    function initialize(address _tokenA, address _tokenB) external {
        require(msg.sender == factory, "NOT_FACTORY");
        tokenA = _tokenA;
        tokenB = _tokenB;
    }
}
```
In the code above, we can see the initialize function need to be called by anoter contract which will send the contract address for handling tokenA and tokenB in the pool. Let's provide a method to get the reserver of tokenA and tokenB:

```sol
uint256 private reserverA;
    uint256 private reserverB;
    uint256 private blockTimestampLast;
    function getReserves() public view returns(
        uint256 _reserveA,
        uint256 _reserveB,
        uint256 _blockTimestampLast
    ) {
        _reserveA = reserverA;
        _reserveB = reserverB;
        _blockTimestampLast = blockTimestampLast;
    }

function _setReserves(uint256 balanceA, uint256 balanceB) private {
        reserverA = balanceA;
        reserverB = balanceB;
        blockTimestampLast = block.timestamp;
    }
```
In above code, we need to keep the reserve number as private and record the time of reserve changing since hackers are incentived to manipulate the reserve number for impacting the trading price. When user trading the tokens in the pool,
they will swap one kind of token for the other, and we need to support the token swapping in the smart contract. Since token trading involves financial, we need to handle it very carefully and we can't call transfer from ERC20 since we need
to revert the transaction if any errors happen in the process.

We will use the low level data call we have seen in previous section. That is we call the transfer method from the token contract with its binary signature, as we have seen in previous section, the low level call will return a bool indicator
to show whether the call is success or not, the code is like following:

```sol
//convert the function signature into binary data
    bytes4 private constant SELECTOR = bytes4(keccak256(
        bytes("transfer(address, uint256)")
    ));

    function _safeTransfer(address token, address to, uint256 value) private {
        /*
        create call data, if the binary data contains a method signture of the contract being call,
        the given contract will call the method and return the calling result
        */
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR,
        to, value));
        //if the call fail, the require will force the transaction to revert
        require(success && (data.length == 0 || 
        abi.decode(data, (bool))), "TRANSFER_FAILED");
    }
```

One thing need to be noticed is that, when contracts located at different address or deployed sperately , and they want to coorperate with each other, using low level call is the norm. This is just like different micro services send messages
to each other, or using RPC or restful API to coorperate together. Now it's time to implement the management of LP token, as we have told before, LP tokens just like dollars for stock exchange, we can use LP tokens to take out some amount
of token pair from the pool and can inject token pair into the pool for getting LP tokens back.

We need to satisfy the following steps for generating LP tokens:
1, compute the number of LP tokens need to be minted.

2,Generate the given amount of LP tokens and transfer them to traders who injecting given number of token pair into the pool.

3,update the number for tokenA and tokenB in the pool.

We need to decide how many LP tokens we need to generate for the given pool, if the product of tokenA with tokenB is K, then the number of LP tokens for the pool is math.sqrt(K).
